name: Build DBK Kernel Driver

on:
  workflow_dispatch:
  push:
    branches: [ master ]
    paths:
      - 'DBKKernel/**'
      - '.github/workflows/build-kernel-driver.yml'
  pull_request:
    branches: [ master ]
    paths:
      - 'DBKKernel/**'
      - '.github/workflows/build-kernel-driver.yml'

permissions: read-all

jobs:
  build-driver:
    runs-on: windows-2022
    timeout-minutes: 90
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Visual Studio 2019 (Enterprise, v142)
        id: install_vs2019
        shell: pwsh
        run: |
          Write-Host "Installing Visual Studio 2019 Enterprise (v142) on windows-2022..."
          
          # If VS2019 already present, skip
          $vs2019Path = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\BuildTools"
          if (Test-Path $vs2019Path) { Write-Host "✅ VS2019 BuildTools already present at $vs2019Path"; exit 0 }
          $vs2019EntPath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise"
          if (Test-Path $vs2019EntPath) { Write-Host "✅ VS2019 Enterprise already present at $vs2019EntPath"; exit 0 }

          # Use direct VS2019 Enterprise installer (C2R)
          try {
            Write-Host "Downloading VS2019 Enterprise installer (C2R)..."
            $vsEntExe = Join-Path $env:TEMP 'vs2019_enterprise.exe'
            Invoke-WebRequest -Uri "https://c2rsetup.officeapps.live.com/c2r/downloadVS.aspx?sku=enterprise&channel=Release&version=VS2019" -OutFile $vsEntExe -UseBasicParsing
            Write-Host "Running VS2019 Enterprise installer..."
            $entArgs = @(
              '--quiet','--wait','--norestart',
              '--installPath',"C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise",
              '--add','Microsoft.VisualStudio.Workload.VCTools',
              '--add','Microsoft.VisualStudio.Component.VC.Tools.x86.x64',
              '--add','Microsoft.VisualStudio.Component.VC.v142.x86.x64',
              '--add','Microsoft.VisualStudio.Component.VC.v142.x86.x64.Spectre',
              '--add','Microsoft.VisualStudio.Component.VC.ATL',
              '--add','Microsoft.VisualStudio.Component.VC.ATL.Spectre',
              '--add','Microsoft.VisualStudio.Component.VC.MFC.x86.x64',
              '--add','Microsoft.VisualStudio.Component.VC.MFC.x86.x64.Spectre',
              '--add','Microsoft.VisualStudio.Component.Windows10SDK.19041',
              '--add','Microsoft.VisualStudio.Component.VC.ATLMFC.Spectre',
              '--add','Microsoft.VisualStudio.Component.WinXP',
              '--includeRecommended'
            )
            # Do not use -Wait so we can print progress and tail logs
            $procEnt = Start-Process -FilePath $vsEntExe -ArgumentList $entArgs -PassThru
            $start = Get-Date
            $timeoutMinutes = 75
            while (-not $procEnt.HasExited) {
              $elapsed = (Get-Date) - $start
              Write-Host ("Installing VS2019 Enterprise... elapsed {0:hh\:mm\:ss}" -f $elapsed)
              # Tail latest installer log for visibility
              try {
                $cands = @()
                $tmpLogs = Get-ChildItem "$env:TEMP" -Filter 'dd_*.log' -ErrorAction SilentlyContinue
                if ($tmpLogs) { $cands += $tmpLogs }
                $bootPath = 'C:\\ProgramData\\Microsoft\\VisualStudio\\Packages\\_bootstrapper'
                if (Test-Path $bootPath) {
                  $cands += Get-ChildItem $bootPath -Recurse -Include *.log -ErrorAction SilentlyContinue
                }
                if ($cands -and $cands.Count -gt 0) {
                  $latest = $cands | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                  Write-Host "Latest installer log: $($latest.FullName) ($($latest.LastWriteTime))"
                  Get-Content $latest.FullName -Tail 20 | ForEach-Object { Write-Host $_ }
                } else {
                  Write-Host "No installer logs found yet..."
                }
              } catch {
                Write-Host "(log tail skipped: $($_.Exception.Message))"
              }
              if ($elapsed.TotalMinutes -gt $timeoutMinutes) {
                Write-Error "VS2019 installer timeout after $timeoutMinutes minutes"
                try { Stop-Process -Id $procEnt.Id -Force -ErrorAction SilentlyContinue } catch {}
                exit 1
              }
              Start-Sleep -Seconds 60
            }
            $procEnt.WaitForExit()
            Write-Host "VS2019 Enterprise installer exit code: $($procEnt.ExitCode)"
            if ($procEnt.ExitCode -eq 0 -or $procEnt.ExitCode -eq 3010) {
              Write-Host "✅ VS2019 Enterprise installed successfully"
            } else {
              Write-Warning "VS2019 Enterprise installer returned $($procEnt.ExitCode). Will try other methods."
              Write-Error "VS2019 installation failed."
              exit 1
            }
          } catch {
            Write-Error "Failed to download/run VS2019 Enterprise C2R installer: $($_.Exception.Message)"
            exit 1
          }
          
          # Verify installation - check both intended and actual paths
          $vs2019Paths = @(
            $vs2019Path,
            $vs2019EntPath,
            "C:\Program",  # Actual install path seen in logs
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise",
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools"
          )
          
          $foundPath = $null
          foreach ($path in $vs2019Paths) {
            if (Test-Path $path) {
              $foundPath = $path
              Write-Host "✅ Found VS2019 at: $path"
              break
            }
          }
          
          if (-not $foundPath) {
            Write-Error "VS2019 not found at any expected location."
            Write-Host "Checked paths:"
            foreach ($path in $vs2019Paths) {
              Write-Host "  - $path (exists: $(Test-Path $path))"
            }
            exit 1
          }

      - name: Collect VS installer logs on failure
        if: failure() && steps.install_vs2019.outcome == 'failure'
        shell: pwsh
        run: |
          Write-Host "Collecting Visual Studio installer logs for diagnostics..."
          $logDirs = @(
            "$env:TEMP",
            'C:\\ProgramData\\Microsoft\\VisualStudio\\Packages\\_bootstrapper'
          )
          $logFiles = @()
          foreach ($d in $logDirs) {
            if (Test-Path $d) {
              $logFiles += Get-ChildItem $d -Recurse -Include *.log -ErrorAction SilentlyContinue
            }
          }
          if (-not $logFiles -or $logFiles.Count -eq 0) {
            Write-Host "No VS installer logs found."
          } else {
            $dest = Join-Path $env:RUNNER_TEMP 'vs_installer_logs.zip'
            if (Test-Path $dest) { Remove-Item $dest -Force }
            Compress-Archive -Path ($logFiles | Select-Object -ExpandProperty FullName) -DestinationPath $dest -Force
            Write-Host ("Logs zipped to {0} (files: {1})" -f $dest, $logFiles.Count)
          }
        continue-on-error: true

      - name: Upload VS installer logs
        if: failure() && steps.install_vs2019.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: vs-installer-logs
          path: ${{ runner.temp }}/vs_installer_logs.zip

      - name: Install Windows 10 SDK 2004 (10.0.19041.0)
        shell: pwsh
        run: |
          Write-Host "Installing Windows 10 SDK 2004 (10.0.19041.0)..."
          
          # Debug: Check what Windows Kits are actually present
          $windowsKitsPath = "${env:ProgramFiles(x86)}\Windows Kits"
          Write-Host "Checking Windows Kits directory: $windowsKitsPath"
          if (Test-Path $windowsKitsPath) {
            Write-Host "Windows Kits directory exists, contents:"
            Get-ChildItem $windowsKitsPath -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  - $($_.Name)" }
            
            $kits10Path = "$windowsKitsPath\10"
            if (Test-Path $kits10Path) {
              Write-Host "Windows Kits 10 directory exists, checking Include subdirectory:"
              $includePath = "$kits10Path\Include"
              if (Test-Path $includePath) {
                Get-ChildItem $includePath -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  - $($_.Name)" }
              } else {
                Write-Host "  Include directory does not exist"
              }
            }
          } else {
            Write-Host "Windows Kits directory does not exist"
          }
          
          $sdkPath = "${env:ProgramFiles(x86)}\Windows Kits\10\Include\10.0.19041.0"
          Write-Host "Checking specific SDK path: $sdkPath"
          Write-Host "Path exists: $(Test-Path $sdkPath)"
          
          if (Test-Path $sdkPath) {
            Write-Host "⚠️ Windows 10 SDK 10.0.19041.0 path exists but forcing reinstall to ensure proper installation"
            # Don't exit, continue with installation
          }

          # Download SDK installer directly
          Write-Host "Downloading Windows 10 SDK installer..."
          $sdkInstaller = "${env:TEMP}\winsdksetup.exe"
          Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2311805" -OutFile $sdkInstaller -UseBasicParsing
          
          Write-Host "Installing SDK with required features..."
          $sdkArgs = "/quiet /norestart /features OptionId.WindowsPerformanceToolkit OptionId.WindowsDesktopDebuggers OptionId.NetFxSoftwareDevelopmentKit OptionId.WindowsIPOverUSB OptionId.WindowsDesktopSigning OptionId.UWPManaged OptionId.UWPCPP OptionId.Win32CPP"
          $sdkProc = Start-Process -FilePath $sdkInstaller -ArgumentList $sdkArgs -PassThru -Wait
          $exitCode = $sdkProc.ExitCode
          Write-Host "SDK installer exit code: $exitCode"
          
          if ($exitCode -eq 0 -or $exitCode -eq 3010) {
            Write-Host "✅ Windows 10 SDK installed successfully"
          } else {
            Write-Warning "SDK installation completed with warnings (exit code $exitCode)"
          }

      - name: Install Windows Driver Kit (WDK)
        shell: pwsh
        run: |
          Write-Host "Installing Windows Driver Kit..."
          
          # Debug: Check what's at the WDK path
          $wdkInclude = "${env:ProgramFiles(x86)}\Windows Kits\10\Include\wdf"
          Write-Host "Checking WDK path: $wdkInclude"
          Write-Host "Path exists: $(Test-Path $wdkInclude)"
          
          # Also check broader Windows Kits structure for WDK
          $windowsKitsPath = "${env:ProgramFiles(x86)}\Windows Kits\10"
          if (Test-Path $windowsKitsPath) {
            Write-Host "Windows Kits 10 exists, checking for WDK components:"
            $includePath = "$windowsKitsPath\Include"
            if (Test-Path $includePath) {
              Write-Host "Include directory contents:"
              Get-ChildItem $includePath -ErrorAction SilentlyContinue | ForEach-Object { 
                Write-Host "  - $($_.Name)"
                if ($_.Name -eq "wdf") {
                  Write-Host "    WDF directory found!"
                  Get-ChildItem $_.FullName -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "      - $($_.Name)" }
                }
              }
            }
            
            # Check for other WDK indicators
            $libPath = "$windowsKitsPath\Lib"
            if (Test-Path $libPath) {
              Write-Host "Lib directory exists"
              $versions = Get-ChildItem $libPath -Directory -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name
              Write-Host "Available lib versions: $($versions -join ', ')"
            }
          }
          
          if (Test-Path $wdkInclude) {
            Write-Host "⚠️ WDK path exists but forcing reinstall to ensure proper installation"
            # Don't exit, continue with installation
          }

          # Download WDK
          $wdkInstaller = "${env:TEMP}\wdksetup.exe"
          Write-Host "Downloading WDK installer..."
          Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2128854" -OutFile $wdkInstaller -UseBasicParsing
          
          Write-Host "Installing WDK (this may take a few minutes)..."
          # Install WDK quietly
          $process = Start-Process -FilePath $wdkInstaller -ArgumentList "/quiet" -Wait -PassThru
          
          if ($process.ExitCode -eq 0) {
            Write-Host "✅ WDK installation completed successfully"
          } else {
            Write-Warning "WDK installation completed with exit code $($process.ExitCode)"
          }

      - name: Integrate WDK with VS2019
        shell: pwsh
        run: |
          Write-Host "Integrating WDK with VS2019..."
          
          # Locate MSBuild to infer VS root and VC targets path
          $msbuildCandidates = @(
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\MSBuild.exe",
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\BuildTools\MSBuild\Current\Bin\MSBuild.exe",
            "C:\\Program\\MSBuild\\Current\\Bin\\MSBuild.exe"
          )
          $msbuild = $msbuildCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $msbuild) {
            Write-Error "MSBuild.exe not found; cannot integrate WDK"
            exit 1
          }
          Write-Host "MSBuild: $msbuild"

          $msbuildBin = Split-Path $msbuild -Parent
          $msbuildCurrent = Split-Path $msbuildBin -Parent
          $msbuildRoot = Split-Path $msbuildCurrent -Parent
          $vsRoot = Split-Path $msbuildRoot -Parent  # often C:\Program or VS install root
          Write-Host "MSBuildRoot: $msbuildRoot"
          Write-Host "VSRoot (inferred): $vsRoot"

          $vcV160 = Join-Path $msbuildRoot "Microsoft\\VC\\v160"
          $platformsRoot = Join-Path $vcV160 "Platforms"
          $wdkPlatformPath = Join-Path $platformsRoot "WindowsKernelModeDriver10.0"
          $toolsetsPath = Join-Path $wdkPlatformPath "PlatformToolsets"
          $toolsetPath = Join-Path $toolsetsPath "WindowsKernelModeDriver10.0"
          Write-Host "Checking toolset folder: $toolsetPath"

          if (-not (Test-Path $toolsetPath)) {
            Write-Host "WindowsKernelModeDriver10.0 toolset missing; attempting VSIX integration..."

            # Locate VSIXInstaller
            $vsixInstallerCandidates = @(
              (Join-Path $vsRoot "Common7\\IDE\\VSIXInstaller.exe"),
              "${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vsixinstaller.exe"
            )
            $vsixInstaller = $vsixInstallerCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $vsixInstaller) {
              Write-Error "VSIXInstaller.exe not found; cannot install WDK VS integration"
              exit 1
            }
            Write-Host "VSIXInstaller: $vsixInstaller"

            # Locate WDK VSIX packages
            # Search likely VSIX locations
            $vsixSearchRoots = @(
              "${env:ProgramFiles(x86)}\\Windows Kits\\10\\Vsix\\VS2019",
              "${env:ProgramFiles(x86)}\\Windows Kits\\10\\Vsix",
              "${env:ProgramFiles(x86)}\\Windows Kits\\10"
            )
            $vsixFiles = @()
            foreach ($root in $vsixSearchRoots) {
              if (Test-Path $root) {
                Write-Host "Scanning VSIX root: $root"
                $found = Get-ChildItem $root -Recurse -Include *.vsix -ErrorAction SilentlyContinue | Where-Object { $_.Name -match 'wdk|wdf|driver' }
                if ($found) { $vsixFiles += $found }
              }
            }
            if (-not $vsixFiles -or $vsixFiles.Count -eq 0) {
              Write-Warning "No WDK/WDF VSIX packages found under: $($vsixSearchRoots -join ', ')"
            } else {
              Write-Host "Found VSIX packages:"
              $vsixFiles | ForEach-Object { Write-Host "  - $($_.FullName)" }
            }

            if ($vsixFiles -and $vsixFiles.Count -gt 0) {
              foreach ($vsix in $vsixFiles) {
                Write-Host "Installing VSIX: $($vsix.FullName)"
                $logPath = Join-Path $env:TEMP ("vsix_" + [Guid]::NewGuid().ToString() + ".log")
                $proc = Start-Process -FilePath $vsixInstaller -ArgumentList @('/quiet', '/admin', '/logFile', $logPath, $vsix.FullName) -PassThru -Wait
                Write-Host "VSIX exit code: $($proc.ExitCode) (log: $logPath)"
              }
            } else {
              Write-Warning "Skipping VSIX installation since none were found"
            }

            # Re-check toolset after VSIX installation
            if (Test-Path $toolsetPath) {
              Write-Host "✅ WindowsKernelModeDriver10.0 toolset is now available"
            } else {
              Write-Warning "WindowsKernelModeDriver10.0 toolset still not found at $toolsetPath"
              # List available toolsets for diagnostics
              if (Test-Path $toolsetsPath) {
                $toolsets = Get-ChildItem $toolsetsPath -Directory | Select-Object -ExpandProperty Name
                Write-Host "Available toolsets: $($toolsets -join ', ')"
              }

              # Fallback: Manually extract toolset files from VSIX and copy into VC targets
              if ($vsixFiles -and $vsixFiles.Count -gt 0) {
                $vsix = $vsixFiles | Select-Object -First 1
                Write-Host "Attempting manual extraction from: $($vsix.FullName)"
                $extractDir = Join-Path $env:TEMP ("wdkvsix_" + [Guid]::NewGuid().ToString())
                New-Item -ItemType Directory -Path $extractDir -Force | Out-Null
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                [System.IO.Compression.ZipFile]::ExtractToDirectory($vsix.FullName, $extractDir)
                # Look for MSBuild extensions inside the VSIX payload
                $candidate = Get-ChildItem -Path $extractDir -Recurse -Directory -ErrorAction SilentlyContinue | Where-Object { $_.FullName -match 'MSBuild.*Microsoft.*VC.*v160.*Platforms.*WindowsKernelModeDriver10.0.*PlatformToolsets' } | Select-Object -First 1
                if ($candidate) {
                  Write-Host "Copying toolset files from $($candidate.FullName) to $toolsetsPath"
                  New-Item -ItemType Directory -Path $toolsetsPath -Force | Out-Null
                  Copy-Item -Path (Join-Path $candidate.FullName '*') -Destination $toolsetsPath -Recurse -Force
                } else {
                  Write-Warning "Could not find MSBuild toolset content inside VSIX at $extractDir"
                }
                # Re-check
                if (Test-Path $toolsetPath) {
                  Write-Host "✅ Toolset became available after manual extraction"
                } else {
                  Write-Warning "Toolset still missing after manual extraction"
                }
              }
            }
          } else {
            Write-Host "✅ WindowsKernelModeDriver10.0 toolset already available"
          }

          # Set environment variables to help MSBuild locate SDK/WDK and VC targets
          Write-Host "Setting WDK/SDK environment variables..."
          [Environment]::SetEnvironmentVariable("WindowsSDKDir", "${env:ProgramFiles(x86)}\Windows Kits\10\", "Process")
          [Environment]::SetEnvironmentVariable("WindowsSDKVersion", "10.0.19041.0\\", "Process")
          [Environment]::SetEnvironmentVariable("VCTargetsPath", (Join-Path $vcV160 ''), "Process")

      - name: Integrate WDK with VS2019
        shell: pwsh
        run: |
          Write-Host "Integrating WDK with VS2019..."
          
          # Check if WDK MSBuild files exist
          $wdkMSBuildPath = "${env:ProgramFiles(x86)}\Windows Kits\10\build"
          if (-not (Test-Path $wdkMSBuildPath)) {
            Write-Error "WDK MSBuild files not found at $wdkMSBuildPath"
            exit 1
          }
          
          # Find VS2019 MSBuild directory
          $vsMSBuildPaths = @(
            "C:\Program\MSBuild\Microsoft\VC",
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise\MSBuild\Microsoft\VC",
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\BuildTools\MSBuild\Microsoft\VC"
          )
          
          $vsMSBuildPath = $null
          foreach ($path in $vsMSBuildPaths) {
            if (Test-Path $path) {
              $vsMSBuildPath = $path
              break
            }
          }
          
          if (-not $vsMSBuildPath) {
            Write-Error "Could not find VS2019 MSBuild VC directory"
            exit 1
          }
          
          Write-Host "VS MSBuild path: $vsMSBuildPath"
          Write-Host "WDK MSBuild path: $wdkMSBuildPath"
          
          # Check for WindowsKernelModeDriver10.0 toolset
          $toolsetPath = Join-Path $vsMSBuildPath "v160\Platforms\x64\PlatformToolsets\WindowsKernelModeDriver10.0"
          if (Test-Path $toolsetPath) {
            Write-Host "✅ WindowsKernelModeDriver10.0 toolset already available"
          } else {
            Write-Host "WindowsKernelModeDriver10.0 toolset not found at $toolsetPath"
            # List available toolsets
            $platformsPath = Join-Path $vsMSBuildPath "v160\Platforms\x64\PlatformToolsets"
            if (Test-Path $platformsPath) {
              $toolsets = Get-ChildItem $platformsPath -Directory | Select-Object -ExpandProperty Name
              Write-Host "Available toolsets: $($toolsets -join ', ')"
            }
          }
          
          # Set environment variable to help MSBuild find WDK
          Write-Host "Setting WDK environment variables..."
          [Environment]::SetEnvironmentVariable("WindowsSDKDir", "${env:ProgramFiles(x86)}\Windows Kits\10\", "Machine")
          [Environment]::SetEnvironmentVariable("WindowsSDKVersion", "10.0.19041.0\", "Machine")

      # setup-msbuild not required; we call VS2019 MSBuild.exe directly

      - name: Build DBKKernel (x64 unsigned)
        shell: pwsh
        working-directory: DBKKernel
        run: |
          Write-Host "Building DBKKernel.sln (Release without sig | x64) with VS2019 MSBuild..."
          
          # Locate VS2019 MSBuild
          $msbuildCandidates = @(
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\MSBuild.exe",
            "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\BuildTools\MSBuild\Current\Bin\MSBuild.exe",
            "C:\Program\MSBuild\Current\Bin\MSBuild.exe",  # Actual install path
            "C:\Program\Common7\Tools\MSBuild\Current\Bin\MSBuild.exe"
          )
          $msbuild = $msbuildCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $msbuild) {
            Write-Error "Could not find VS2019 MSBuild.exe"
            Write-Host "Checked paths:"
            foreach ($path in $msbuildCandidates) {
              Write-Host "  - $path (exists: $(Test-Path $path))"
            }
            exit 1
          }
          Write-Host "Using MSBuild: $msbuild"

          # Diagnostics: list VC/v160 platforms/toolsets
          $vcRoot = Join-Path (Split-Path (Split-Path (Split-Path $msbuild) -Parent) -Parent) 'Microsoft\VC\v160'
          Write-Host "VC v160 root: $vcRoot (exists: $(Test-Path $vcRoot))"
          $pt = Join-Path $vcRoot 'Platforms'
          if (Test-Path $pt) {
            Write-Host 'Platform folders:'
            Get-ChildItem $pt -Directory | ForEach-Object { Write-Host " - $($_.FullName)" }
            $wdkToolsets = Join-Path $pt 'WindowsKernelModeDriver10.0\PlatformToolsets'
            Write-Host "WDK toolsets path: $wdkToolsets (exists: $(Test-Path $wdkToolsets))"
            if (Test-Path $wdkToolsets) {
              Get-ChildItem $wdkToolsets -Directory | ForEach-Object { Write-Host "   * Toolset: $($_.Name)" }
            }
          }

          # Ensure Windows SDK 10.0.19041.0 exists
          $sdk19041Path = "${env:ProgramFiles(x86)}\Windows Kits\10\Include\10.0.19041.0"
          if (-not (Test-Path $sdk19041Path)) {
            Write-Error "Required Windows 10 SDK 10.0.19041.0 not found at $sdk19041Path"
            exit 1
          }

          # Build with OutDir override and disable post-build signing
          # Ensure environment hints for SDK and VC targets
          $env:WindowsSDKDir = "${env:ProgramFiles(x86)}\Windows Kits\10\"
          $env:WindowsSDKVersion = "10.0.19041.0\"
          $env:VCTargetsPath = Join-Path (Split-Path (Split-Path (Split-Path $msbuild) -Parent) -Parent) 'Microsoft\VC\v160\'

          & "$msbuild" "DBKKernel.sln" /m /t:Build /p:Configuration="Release without sig" /p:Platform=x64 `
            /p:PlatformToolset=WindowsKernelModeDriver10.0 `
            /p:WindowsTargetPlatformVersion=10.0.19041.0 `
            /p:VCTargetsPath="$env:VCTargetsPath" `
            /p:OutDir="$(Resolve-Path .)\build\" `
            /p:PostBuildEventUseInBuild=false
          if ($LASTEXITCODE -ne 0) {
            Write-Error "MSBuild failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
          Write-Host "✅ Build completed"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: DBKKernel-x64-unsigned-${{ github.sha }}
          path: |
            DBKKernel/build/**/*.sys
            DBKKernel/build/**/*.inf
            DBKKernel/build/**/*.pdb
            DBKKernel/DBK64.inf
          if-no-files-found: error

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.sha }}
          path: |
            DBKKernel/**/*.log
            DBKKernel/**/*.err
          if-no-files-found: ignore